import torch
import torch.nn as nn
import torch.optim as optim
import torchvision.transforms as transforms
from torch.utils.data import DataLoader

# Verificar si CUDA está disponible
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

# Definir una red neuronal convolutiva modificada para tus datos
class CustomCNN(nn.Module):
    def __init__(self):
        super(CustomCNN, self).__init__()
        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, stride=1, padding=1)
        self.relu1 = nn.ReLU()
        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)

        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)
        self.relu2 = nn.ReLU()
        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)

        self.flatten = nn.Flatten()
        self.fc1 = nn.Linear(64 * 125 * 125, 128)
        self.relu3 = nn.ReLU()
        self.fc2 = nn.Linear(128, 19)

    def forward(self, x):
        x = self.pool1(self.relu1(self.conv1(x)))
        x = self.pool2(self.relu2(self.conv2(x)))
        x = self.flatten(x)
        x = self.relu3(self.fc1(x))
        x = self.fc2(x)
        return x

# Aquí asumimos que las imágenes están normalizadas en el rango [0, 1]
transform = transforms.Compose([
        transforms.CenterCrop(790),         # Randomly crop the image to 400x400
        transforms.Resize((500, 500)),       # Resize the image
        transforms.RandomRotation(5),      # Rotate the image by up to 5 degrees
        transforms.ColorJitter(brightness=0.2, hue=0.2, saturation=0.2),           # Randomly change brightness, contrast, saturation, and hue
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])  # Normalize using ImageNet statistics
    ])


# Puedes cargar tus datos personalizados aquí, reemplazando esto con tu propio DataLoader
# train_dataset = ...  # Reemplaza con tu propio conjunto de datos
# train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)
##### Clase de dataset
class Affection(Dataset):
    def __init__(self, img_dir, dataframe, transform=None):
        self.X = img_dir

        self.y = dataframe

        self.transform = transform

    def __len__(self):
        return len(self.y)

    def __getitem__(self, idx):
        img_id = self.y.iloc[idx,0]
        relevant_row = self.y.iloc[idx, [i for i in range(self.y.shape[1]) if i not in [0, 20, 21]]]
        labels = torch.tensor(relevant_row)

        image_path = self.X+'/'+img_id
        image = Image.open(image_path).convert('RGB')
        
        if self.transform:
            image = self.transform(image)

        breakpoint()
        return image, labels


# Crear la instancia del modelo y enviarlo a CUDA
model = CustomCNN().to(device)

# Definir la función de pérdida y el optimizador
criterion = nn.BCEWithLogitsLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Ejemplo de entrenamiento (ajústalo según tus datos reales)
num_epochs = 5
for epoch in range(num_epochs):
    for inputs, labels in train_loader:
        inputs, labels = inputs.to(device), labels.to(device)
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()

    print(f'Epoch [{epoch + 1}/{num_epochs}], Loss: {loss.item()}')

print("Entrenamiento completado.")
